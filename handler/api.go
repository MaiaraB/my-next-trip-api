/*
 * Flight Planner
 *
 * This is a Flight Planner server.
 *
 * API version: 1.0.0
 * Contact: maiarabarroso84@gmail.com
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package handler

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"time"

	"github.com/MaiaraB/travel-plan/models"
)

const (
	layoutISO = "2006-01-02"
)

func getFlights(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	ctxWithTimeout, cancelFunction := context.WithTimeout(ctx, time.Duration(20)*time.Second)

	defer func() {
		log.Println("getFlights defer: canceling context")
		cancelFunction()
	}()

	data, intervals, err := createDataAndIntervalsForSkyscannerAPI(r)

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.Header().Set("Access-Control-Allow-Origin", "*")

	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	w.WriteHeader(http.StatusOK)

	flusher, ok := w.(http.Flusher)
	if !ok {
		log.Printf("Expected http.ResponseWriter to be an http.Flusher")
	}

	// Sending the number of response chunks for tracking loading purposes
	w.Write([]byte(fmt.Sprintf("%d<", len(intervals))))
	flusher.Flush()

	isRoundTrip := (r.URL.Query().Get("duration") != "")
	results := make(chan []models.FlightsResult, len(intervals))

	for i := 0; i < len(intervals); i++ {
		dataCopy := copyValues(data)
		dataCopy.Set("outboundDate", intervals[i].Outbound.Format(layoutISO))
		if isRoundTrip {
			dataCopy.Set("inboundDate", intervals[i].Inbound.Format(layoutISO))
		}

		go getPartialResults(ctxWithTimeout, results, dataCopy, i)
	}

	for i := 0; i < len(intervals); i++ {
		// json.NewEncoder(w).Encode(flightResults)
		select {
		case <-ctxWithTimeout.Done():
			close(results)
			return
		case flightResults := <-results:
			flightResultJSON, err := json.Marshal(flightResults)
			if err != nil {
				log.Printf("The response marshalling failed with error %s\n", err)
			}
			w.Write(flightResultJSON)
			w.Write([]byte("<"))
			flusher.Flush()
			log.Println("Finished thread #", i)
		}
	}
}
