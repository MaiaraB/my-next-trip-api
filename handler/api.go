/*
 * Flight Planner
 *
 * This is a Flight Planner server.
 *
 * API version: 1.0.0
 * Contact: maiarabarroso84@gmail.com
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package handler

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"time"

	"github.com/MaiaraB/travel-plan/models"
)

const (
	layoutISO = "2006-01-02"
)

func getFlights(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	ctxWithTimeout, cancelFunction := context.WithTimeout(ctx, time.Duration(20)*time.Second)

	defer func() {
		log.Println("getFlights defer: canceling context")
		cancelFunction()
	}()

	data, intervals, err := createDataAndIntervalsForSkyscannerAPI(r)

	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	// w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.Header().Set("Access-Control-Allow-Origin", "*")
	w.WriteHeader(http.StatusOK)

	flusher, ok := w.(http.Flusher)
	if !ok {
		log.Printf("Expected http.ResponseWriter to be an http.Flusher")
	}

	// Sending the number of response chunks for tracking loading purposes
	w.Write([]byte(fmt.Sprintf("%d<", len(intervals))))
	flusher.Flush()

	isRoundTrip := (r.URL.Query().Get("duration") != "")
	results := make(chan []models.FlightsResult, len(intervals))

	for i := 0; i < len(intervals); i++ {
		dataCopy := copyValues(data)
		dataCopy.Set("outboundDate", intervals[i].Outbound.Format(layoutISO))
		if isRoundTrip {
			dataCopy.Set("inboundDate", intervals[i].Inbound.Format(layoutISO))
		}

		go getPartialResults(ctxWithTimeout, results, dataCopy, i)
	}

	for i := 0; i < len(intervals); i++ {
		// json.NewEncoder(w).Encode(flightResults)
		select {
		case <-ctxWithTimeout.Done():
			close(results)
			return
		case flightResults := <-results:
			flightResultJSON, err := json.Marshal(flightResults)
			if err != nil {
				log.Printf("The response marshalling failed with error %s\n", err)
			}
			w.Write(flightResultJSON)
			w.Write([]byte("<"))
			flusher.Flush()
			log.Println("Finished thread #", i)
		}
	}
}

func getCountries(w http.ResponseWriter, r *http.Request) {
	queryValues := r.URL.Query()
	locale := queryValues.Get("locale")

	countries := getCountriesSkyscanner(locale)

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.Header().Set("Access-Control-Allow-Origin", "*")
	w.WriteHeader(http.StatusOK)

	countriesJSON, err := json.Marshal(countries)
	if err != nil {
		log.Printf("The response marshalling failed with error %s\n", err)
	}

	w.Write(countriesJSON)
}

func getCurrencies(w http.ResponseWriter, r *http.Request) {
	currencies := getCurrenciesSkyscanner()

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.Header().Set("Access-Control-Allow-Origin", "*")
	w.WriteHeader(http.StatusOK)

	currenciesJSON, err := json.Marshal(currencies)
	if err != nil {
		log.Printf("The response marshalling failed with error %s\n", err)
	}
	w.Write(currenciesJSON)
}

func getPlaces(w http.ResponseWriter, r *http.Request) {
	queryValues := r.URL.Query()
	country := queryValues.Get("country")
	currency := queryValues.Get("currency")
	locale := queryValues.Get("locale")
	query := queryValues.Get("query")

	places := getPlacesSkyscanner(country, currency, locale, query)

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.Header().Set("Access-Control-Allow-Origin", "*")
	w.WriteHeader(http.StatusOK)

	placesJSON, err := json.Marshal(places)
	if err != nil {
		log.Printf("The response marshalling failed with error %s\n", err)
	}

	w.Write(placesJSON)
}
